/**
 * Encode app configuration in a URL fragment.
 *
 * This is used by the annotator to pass configuration to the sidebar and
 * notebook apps, which they can easily read on startup. The configuration is
 * passed in the fragment to avoid invalidating cache entries for the URL
 * or adding noise to server logs.
 *
 * @return URL with added fragment
 */
export function addConfigFragment(baseURL: string, config: object): string {
  const url = new URL(baseURL);
  const params = new URLSearchParams();
  params.append('config', JSON.stringify(config));
  url.hash = params.toString();
  return url.toString();
}

/**
 * Parse configuration from a URL generated by {@link addConfigFragment}.
 */
export function parseConfigFragment(url: string): Record<string, unknown> {
  try {
    const configStr = new URL(url).hash.slice(1);
    const configJSON = new URLSearchParams(configStr).get('config');

    if (!configJSON) {
      return Object.create(null); // Return an empty, safe object
    }

    const parsedConfig = JSON.parse(configJSON);

    // Ensure parsed object is safe and doesn't pollute prototypes
    if (typeof parsedConfig !== 'object' || parsedConfig === null) {
      return Object.create(null);
    }

    const safeConfig: Record<string, unknown> = Object.create(null);

    // Copy valid properties to a safe object
    for (const [key, value] of Object.entries(parsedConfig)) {
      if (!isPrototypePollutionKey(key)) {
        safeConfig[key] = value;
      }
    }

    return safeConfig;
  } catch (err) {
    console.warn('Failed to parse config fragment:', err);
    return Object.create(null); // Return an empty, safe object on failure
  }
}

// Utility to detect dangerous keys
function isPrototypePollutionKey(key: string): boolean {
  return key === '__proto__' || key === 'constructor' || key === 'prototype';
}
